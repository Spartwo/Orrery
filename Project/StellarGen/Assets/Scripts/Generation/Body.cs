
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using RandomUtils = StellarGenHelpers.RandomUtils;
using PhysicsUtils = StellarGenHelpers.PhysicsUtils;
using ColorUtils = StellarGenHelpers.ColorUtils;
using JsonUtils = StellarGenHelpers.JsonUtils;
using UnityEngine;
using static UnityEngine.Rendering.DebugUI;
using System.Linq;
using static Unity.VisualScripting.Metadata;

[Serializable]
public class Body
{
    protected int seedValue;
    private int parent;
    private string name;

    private decimal age;
    private decimal mass;

    private float hillSphere;
    private int[] orbitLine;
    private OrbitalProperties orbit;

    // The generated stellar data
    private List<Body> childBodies = new List<Body>();

    public Body(int newSeedValue)
    {
        // Distinguish seed value from other generated bodies
        float divisor = RandomUtils.RandomFloat(1f, 10f, newSeedValue);
        Debug.Log(divisor);
        seedValue = (int)Math.Round(newSeedValue / divisor);
        Debug.Log("Seed Value: " + seedValue);
    }

    #region Orbit Handlers

    public void GenerateOrbit(float SMAInput, float MeanEccentricity, float MaxInclination)
    {
        // Jiggle the orbit a little within a permissible range
        float semiMajorAxis = SMAInput + (RandomUtils.RandomFloat(-0.03f, 0.03f, seedValue) * SMAInput);

        // Generate Eccentricity with a basis in the mean solar eccentricity
        // Mean is generated by shared SOI and isn't the actual mean
        float eccentricity = RandomUtils.RandomFloat(0.001f, MeanEccentricity * 2, seedValue);

        // Generate the angle where the orbit goes from below the equator to above it
        float longitudeOfAscending = RandomUtils.RandomFloat(0f, 359f, seedValue);

        // Generate the inclination of the body in a given range
        float inclination = RandomUtils.RandomFloat(0f, MaxInclination, seedValue);

        // Generate how far in the inclined disk the body will set its periapsis
        float periArgument = RandomUtils.RandomFloat(0f, 359f, seedValue);
        
        // Create new OrbitData Instance
        orbit = new OrbitalProperties(semiMajorAxis, eccentricity, longitudeOfAscending, inclination, periArgument);
        
        Debug.Log(orbit);

        // Give the orbit an initial colour
        OrbitLine = ColorUtils.ColorToArray(RandomUtils.RandomColor(seedValue));
        Debug.Log(orbitLine);
    }

    /// <summary>
    /// Checks whether a body's orbit is stable within the sphere of its parent
    /// </summary>
    /// <returns>True if the orbit is stable, otherwise false.</returns>
    public bool CheckOrbit()
    {
        // Get the mimimum hill sphere of the parent body
        Body parent = PhysicsUtils.FindParent(Parent);
        // Calculate the semi-minor axis using the formula b = a⋅/1−e^2
        float semiMinorAxis = (float)(parent.orbit.SemiMajorAxis * Math.Sqrt(1 - Math.Pow(parent.orbit.Eccentricity, 2)));
        // Use the semi-minor to estimate the smallest hill
        hillSphere = PhysicsUtils.CalculateHillSphere(parent, semiMinorAxis);

        // True if the semi-major axis is within the hillsphere of the parent
        return orbit.SemiMajorAxis < hillSphere;
    }

    #endregion

    #region Childcare

    /// <summary>
    /// Base method to generate planets, moons, etc
    /// </summary>
    /// <param name="children">The elements being passed downwards from the inherited classes</param>
    public void GenerateChildren(List<Body> children = null)
    { 
        
    }

    /// <summary>
    /// Adds a new child body to the list of child bodies.
    /// </summary>
    /// <param name="newChild">The new body to be added to the child list</param>
    public void AddChild(Body newChild)
    {
        // Check if a body with the same seedValue isn't already present
        if (!childBodies.Any(child => child.SeedValue == newChild.SeedValue))
        {
            childBodies.Add(newChild);
        }
    }

    /// <summary>
    /// Removes a child body from the list by its seed value.
    /// </summary>
    /// <param name="seedValue">The seed value of the body to be removed</param>
    /// <returns>The removed body if found, otherwise null</returns>
    public Body RemoveChild(int seedValue)
    {
        // Find the body with the matching seedValue
        Body bodyToRemove = childBodies.FirstOrDefault(child => child.SeedValue == seedValue);

        if (bodyToRemove != null)
        {
            // Remove the found body from the list
            childBodies.Remove(bodyToRemove);
            return bodyToRemove;
        }
        else
        {
            Debug.LogWarning($"Child body {seedValue} not found.");
            return null;
        }
    }

    #endregion

    #region Getters and Setters

    // Body Name for distinction
    public string Name
    {
        get => name;
        set => name = value;
    }
    // SeedValue of body being orbited
    public int Parent
    {
        get => parent;
        set => parent = value;
    }
    // Unique identifier and generation seed
    public int SeedValue
    {
        get => seedValue;
        private set => seedValue = value;
    }

    // Unified value in earth masses
    public decimal Mass
    {
        get => mass;
        set => mass = value;
    }

    // The range to which this body is the main gravitational point
    [JsonIgnore] 
    public float HillSphere
    {
        get => hillSphere;
        set => hillSphere = value;
    }

    // Age stored in billions

    public decimal Age
    {
        get => age;
        set => age = value;
    }

    // Orbital Line gets and sets translates from serializeable float array to a color
    public int[] OrbitLine
    {
        get
        {
            // If the array is empty generate a color first
            if (orbitLine == null)
            {
                orbitLine = ColorUtils.ColorToArray(RandomUtils.RandomColor(seedValue));
            }

            // Return a color made from the RGB elements of the array
            return orbitLine;
        }
        set => orbitLine = value;
    }

    // Orbital Data
    public OrbitalProperties Orbit
    {
        get => orbit;
        set => orbit = value;
    }

    // Child Body Array
    public List<Body> ChildBodies
    {
        get => childBodies;
        set
        {
            // Provide a default empty list if the list or new list are null
            if (value == null || childBodies == null)
            {
                childBodies = new List<Body>();
            }
            Debug.Log("Adding " + value.Count + " Children");
            childBodies = value;
        }
    }

    #endregion
}

// Orbital properties are a subvalue of all bodies
[Serializable]
public class OrbitalProperties
{
    private float semiMajorAxis; // Semi-Major Axis
    private float eccentricity; // Eccentricity
    private float longitudeOfAscending; // Longitude of Ascending Node
    private float inclination; // Inclination
    private float periArgument; // Argument of Periapsis

    // Constructor
    public OrbitalProperties(float semiMajorAxis, float eccentricity, float longitudeOfAscending, float inclination, float periArgument)
    {
        this.SemiMajorAxis = Math.Max(semiMajorAxis, 0.0001f);
        this.Eccentricity = Math.Clamp(eccentricity, 0f, 0.9999f); ;
        this.LongitudeOfAscending = longitudeOfAscending;
        this.Inclination = inclination;
        this.PeriArgument = periArgument;
    }

    #region Getter and Setters

    public float SemiMajorAxis
    {
        get => semiMajorAxis;
        set => semiMajorAxis = Math.Max(value, 0.0001f);
    }

    public float Eccentricity
    {
        get => eccentricity;
        // Eccentricity cannot be more than 1
        set => eccentricity = Math.Clamp(value, 0f, 0.9999f);
    }

    public float LongitudeOfAscending
    {
        get => longitudeOfAscending;
        set => longitudeOfAscending = value;
    }

    public float Inclination
    {
        get => inclination;
        set => inclination = value;
    }

    public float PeriArgument
    {
        get => periArgument;
        set => periArgument = value;
    }
    #endregion
}
